;;;
;;; PgBouncer Configuration - Session Mode
;;;
;;; Implements Task P0-32: Hybrid pgBouncer Pool Strategy for Long Transactions
;;;
;;; Use Case: Embedding workers (long-running transactions 10-30 seconds)
;;; Port: 6433
;;;
;;; Architecture:
;;;   Embedding Workers (10-20) → pgBouncer (10 connections) → PostgreSQL (100 max)
;;;
;;; CRITICAL DIFFERENCE FROM TRANSACTION MODE:
;;;   - Session mode: Connection held for entire client session
;;;   - Allows long transactions, temp tables, prepared statements
;;;   - PostgreSQL session variables persist across queries
;;;

[databases]
; Database connection string
ga4_analytics = host=postgres port=5432 dbname=ga4_analytics user=postgres password=postgres

; Fallback database for pgbouncer stats
pgbouncer = host=postgres port=5432 dbname=pgbouncer user=postgres password=postgres

[pgbouncer]
;;;
;;; Administrative settings
;;;
logfile = /var/log/pgbouncer/pgbouncer_session.log
pidfile = /var/run/pgbouncer/pgbouncer_session.pid
listen_addr = *
listen_port = 5432
unix_socket_dir = /tmp
auth_type = trust
auth_file = /etc/pgbouncer/userlist.txt

;;;
;;; Pool mode (CRITICAL)
;;;
;;; session: Connection held for entire client session
;;;          Required for embedding workers:
;;;          - Long transactions (10-30 seconds)
;;;          - PostgreSQL session variables (SET app.tenant_id)
;;;          - Temporary tables
;;;          - Prepared statements
;;;
pool_mode = session

;;;
;;; Connection limits
;;;
;;; IMPORTANT: Lower limits than transactional mode
;;;   - Fewer concurrent workers (10-20 vs 1000)
;;;   - Each worker holds connection longer
;;;   - Connection held for entire embedding batch
;;;
max_client_conn = 100        ; Max embedding workers
default_pool_size = 10       ; Connections to PostgreSQL per database
reserve_pool_size = 2        ; Extra connections for bursts
max_db_connections = 20      ; Hard limit for this pgBouncer instance

;;;
;;; Connection behavior
;;;
server_lifetime = 7200       ; Close server connections after 2 hours (longer for session mode)
server_idle_timeout = 1800   ; Close idle server connections after 30 min (longer)
server_connect_timeout = 15  ; Timeout for connecting to PostgreSQL
server_login_retry = 15      ; Retry failed connections after 15s

;;;
;;; Client behavior
;;;
client_idle_timeout = 3600   ; Close idle clients after 1 hour
client_login_timeout = 60    ; Timeout for client authentication

;;;
;;; Low-level socket settings
;;;
pkt_buf = 4096              ; Packet buffer size
max_packet_size = 2147483647 ; Max packet size (2GB)
listen_backlog = 128        ; Socket listen backlog

;;;
;;; Logging
;;;
; log_connections = 1        ; Log all connections (disable in prod)
; log_disconnections = 1     ; Log all disconnections
; log_pooler_errors = 1      ; Log pooler errors
min_pool_size = 2           ; Minimum idle connections to maintain

;;;
;;; DNS settings
;;;
dns_max_ttl = 15            ; DNS cache TTL
dns_nxdomain_ttl = 15       ; Negative DNS cache TTL

;;;
;;; TLS/SSL (if needed)
;;;
; server_tls_sslmode = prefer
; server_tls_ca_file = /etc/ssl/certs/ca.pem
; client_tls_sslmode = prefer
; client_tls_ca_file = /etc/ssl/certs/ca.pem

;;;
;;; Performance tuning for embedding workload
;;;
; For embedding generation (long transactions):
; - session mode: connection held for entire client session
; - Lower max_client_conn: fewer concurrent workers (10-20 vs 1000)
; - Lower default_pool_size: each connection used longer (10 vs 25)
; - Higher timeouts: allows 10-30 second transactions
; - PostgreSQL session variables persist (required for RLS)
;
;;; Example embedding workflow:
;;;   1. Worker connects → gets dedicated connection from pool
;;;   2. SET app.tenant_id = 'uuid' → session variable persists
;;;   3. BEGIN transaction
;;;   4. Generate embeddings (10-30 seconds)
;;;   5. Bulk INSERT INTO ga4_embeddings (1000 rows)
;;;   6. COMMIT transaction
;;;   7. Worker disconnects → connection returns to pool
;;;
